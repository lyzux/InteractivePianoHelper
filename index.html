<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Klavierbass-Rhythmen</title>
    <script src="https://cdn.jsdelivr.net/npm/vexflow@4.2.2/build/cjs/vexflow.js"></script>
    <link rel="stylesheet" href="css/styles.css">
</head>
<body>
    <div class="container">
        <h1>üéπ Klavier-Patterns √úbersicht</h1>
        
        <div class="controls">
            <div class="control-group">
                <label for="pattern">Rhythmus-Muster</label>
                <select id="pattern">
                    <!-- Patterns will be populated by JavaScript -->
                </select>
            </div>
            
            <div class="control-group">
                <label for="key">Tonart</label>
                <select id="key">
                    <option value="C">C-Dur</option>
                    <option value="G">G-Dur</option>
                    <option value="F">F-Dur</option>
                    <option value="Am">A-Moll</option>
                    <option value="Dm">D-Moll</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="tempo">Tempo (BPM)</label>
                <input type="range" id="tempo" min="60" max="180" value="120">
                <div class="tempo-display" id="tempoDisplay">120 BPM</div>
            </div>
            
            <div class="control-group">
                <label>&nbsp;</label>
                <button id="playBtn">‚ñ∂ Abspielen</button>
            </div>
            
            <div class="control-group">
                <label>&nbsp;</label>
                <button id="stopBtn" class="stop">‚èπ Stoppen</button>
            </div>
            
            <div class="control-group">
                <label>&nbsp;</label>
                <div class="pedal-control">
                    <input type="checkbox" id="sustain" checked>
                    <label for="sustain">üéπ Sustain-Pedal</label>
                </div>
            </div>
        </div>
        
        <div class="pattern-info" id="patternInfo">
            <h2>Pattern-Details</h2>
            <p>W√§hlen Sie ein Rhythmus-Muster aus, um Details zu sehen.</p>
        </div>
        
        
        <div class="staff-notation">
            <h3>Notensystem:</h3>
            <div id="vexflow-notation"></div>
        </div>
        
        <div class="piano-container">
            <div class="piano" id="piano">
                <!-- Piano keys will be generated by JavaScript -->
            </div>
        </div>
    </div>

    <script type="module">
        // Einfache Pattern-Loader Klasse direkt hier definiert
        class SimplePatternLoader {
            constructor() {
                this.patterns = new Map();
            }

            registerPattern(id, pattern) {
                this.patterns.set(id, pattern);
            }

            getPattern(id) {
                return this.patterns.get(id);
            }

            getAllPatterns() {
                return Array.from(this.patterns.entries()).map(([id, pattern]) => ({
                    id, ...pattern
                }));
            }

            getPatternOptions() {
                return this.getAllPatterns().map(pattern => ({
                    value: pattern.id,
                    label: pattern.name
                }));
            }

            generateVexFlowNotation(patternId, key) {
                const pattern = this.getPattern(patternId);
                if (!pattern) return null;

                const patternData = pattern.pattern(key);
                const timing = pattern.timing;
                
                // Get bass and treble clef data
                const bassClefNotes = pattern.bassClef ? pattern.bassClef(key) : (pattern.leftHand ? pattern.leftHand(key) : patternData);
                const trebleClefNotes = pattern.trebleClef ? pattern.trebleClef(key) : (pattern.rightHand ? pattern.rightHand(key) : null);
                const bassClefFingering = pattern.bassClefFingering || pattern.leftHandFingering || pattern.fingering;
                const trebleClefFingering = pattern.trebleClefFingering || pattern.rightHandFingering;
                
                return {
                    bassClef: {
                        notes: bassClefNotes,
                        fingering: bassClefFingering,
                        timing: timing
                    },
                    trebleClef: trebleClefNotes ? {
                        notes: trebleClefNotes,
                        fingering: trebleClefFingering,
                        timing: timing
                    } : null,
                    timeSignature: pattern.timeSignature || '4/4',
                    key: key
                };
            }

            // Convert note string to VexFlow format
            convertToVexFlowNote(note, clef = 'treble') {
                if (!note) return null; // Rest
                
                if (Array.isArray(note)) {
                    // Chord - return array of note strings
                    return note.map(n => this.convertSingleNoteToVexFlow(n, clef));
                }
                
                return this.convertSingleNoteToVexFlow(note, clef);
            }
            
            // Helper function to convert single note to VexFlow format
            convertSingleNoteToVexFlow(note, clef = 'treble') {
                let noteName = note.charAt(0).toLowerCase();
                let octave = parseInt(note.slice(-1));
                let accidental = note.slice(1, -1);
                
                // Handle accidentals - VexFlow uses # and b directly
                if (accidental === '#') {
                    noteName += '#';
                } else if (accidental === 'b') {
                    noteName += 'b';
                }
                
                // VexFlow octave mapping - no adjustment needed when clef is properly specified
                const adjustedOctave = octave;
                
                const result = `${noteName}/${adjustedOctave}`;
                console.log(`Converting ${note} for ${clef} clef: ${result}`);
                
                return result;
            }

            // Convert timing to VexFlow duration
            convertTimingToVexFlowDuration(timing) {
                if (timing === 0.25) return '16'; // Sixteenth note
                if (timing === 0.5) return '8';   // Eighth note
                if (timing === 0.75) return '8d'; // Dotted eighth
                if (timing === 1) return 'q';     // Quarter note
                if (timing === 1.5) return 'qd';  // Dotted quarter
                if (timing === 2) return 'h';     // Half note
                if (timing === 3) return 'hd';    // Dotted half
                if (timing === 4) return 'w';     // Whole note
                return 'q'; // Default to quarter note
            }

            // Automatisches Laden aller Patterns
            async autoLoadPatterns() {
                console.log('üîÑ Lade Patterns automatisch...');
                
                const knownPatterns = [
                    'alberti', 'waltz', 'march', 'boogie', 'stride', 'bossa',
                    'ragtime', 'ballad', 'tango', 'habanera', 'arpeggien',
                    'lombardisch', 'chaconne', 'oktav', 'ostinato', 'pompa', 'polonaise',
                    'classical', 'hymn'
                ];

                let loadedCount = 0;
                for (const patternId of knownPatterns) {
                    try {
                        console.log(`Versuche zu laden: ${patternId}`);
                        // Cache-Busting f√ºr aktualisierte Pattern-Dateien
                        const timestamp = Date.now();
                        const module = await import(`./patterns/${patternId}.js?v=${timestamp}`);
                        const pattern = module[patternId];
                        
                        if (pattern) {
                            this.registerPattern(patternId, pattern);
                            console.log(`‚úÖ Geladen: ${pattern.name}`);
                            
                            // Debug: Zeige Pattern-Daten f√ºr Patterns mit Pausen
                            if (['polonaise', 'tango', 'bossa'].includes(patternId)) {
                                const testNotes = pattern.pattern('C');
                                console.log(`üîç Debug ${patternId}:`, testNotes);
                                console.log(`üîç Timing ${patternId}:`, pattern.timing);
                                console.log(`üîç Fingering ${patternId}:`, pattern.fingering);
                            }
                            
                            loadedCount++;
                        }
                    } catch (error) {
                        console.log(`‚ö™ ${patternId}.js nicht gefunden`);
                    }
                }

                console.log(`üéµ ${loadedCount} Patterns geladen!`);
                
                // Debug: Teste Pausen-Pattern
                this.addTestPattern();
                
                return loadedCount > 0;
            }

            // Debug: Erstelle Test-Pattern mit Pausen
            addTestPattern() {
                const testPattern = {
                    name: 'Test-Pausen',
                    description: 'Test-Pattern um Pausen zu √ºberpr√ºfen',
                    notation: 'C3 - (Pause) - G3 - (Pause)',
                    pattern: (key) => {
                        return ['C3', null, 'G3', null];
                    },
                    timing: [1, 1, 1, 1],
                    fingering: [5, null, 3, null],
                    timeSignature: '4/4',
                    tempo: { min: 80, max: 120, default: 100 }
                };
                
                this.registerPattern('test-pausen', testPattern);
                console.log('üîß Test-Pausen Pattern hinzugef√ºgt');
            }
        }

        // Import modules (nur die funktionierenden)
        import { AudioEngine } from './js/audioEngine.js';
        import { Piano } from './js/piano.js';
        import { Settings } from './js/settings.js';
        import { Player } from './js/player.js';

        // Asynchrone Initialisierung
        async function initializeApp() {
            // Initialize components
            const audioEngine = new AudioEngine();
            const piano = new Piano('piano', audioEngine);
            const settings = new Settings();
            const patternLoader = new SimplePatternLoader(); // Verwende einfache Version
            const player = new Player(audioEngine, piano, settings);

            // Patterns automatisch laden
            console.log('üîÑ Starte automatisches Pattern-Loading...');
            const success = await patternLoader.autoLoadPatterns();
            
            if (!success || patternLoader.getAllPatterns().length === 0) {
                console.warn('‚ö†Ô∏è Automatisches Laden fehlgeschlagen - verwende Fallback');
                await loadPatternsFallback(patternLoader);
            }

            // Initialize settings
            console.log('üîß Initialisiere Settings...');
            settings.init('tempo', 'tempoDisplay', 'sustain', 'key');
            
            // Try to load saved settings
            settings.load();
            
            // Debug: Teste ob Tempo-Slider gefunden wurde
            const tempoSlider = document.getElementById('tempo');
            console.log('üîß Tempo Slider gefunden:', tempoSlider);
            if (tempoSlider) {
                console.log('üîß Tempo Slider Wert:', tempoSlider.value);
            }

            return { audioEngine, piano, settings, patternLoader, player };
        }

        // Fallback: Manuelle Pattern-Registrierung falls Auto-Load fehlschl√§gt
        async function loadPatternsFallback(patternLoader) {
            console.log('üîß Lade Patterns manuell als Fallback...');
            
            // Minimaler Fallback mit einem Pattern
            const albertiPattern = {
                name: 'Alberti-Bass',
                description: 'Ein klassisches Begleitmuster, benannt nach Domenico Alberti.',
                notation: 'C - G - E - G (1 - 5 - 3 - 5)',
                pattern: (key) => {
                    const patterns = {
                        'C': ['C3', 'G3', 'E3', 'G3'],
                        'G': ['G2', 'D3', 'B2', 'D3'],
                        'F': ['F3', 'C4', 'A3', 'C4'],
                        'Am': ['A2', 'E3', 'C3', 'E3'],
                        'Dm': ['D3', 'A3', 'F3', 'A3']
                    };
                    return patterns[key];
                },
                timing: [1, 1, 1, 1],
                fingering: [1, 5, 3, 5],
                timeSignature: '4/4'
            };
            
            patternLoader.registerPattern('alberti', albertiPattern);
            console.log('‚úÖ Fallback Pattern geladen: Alberti-Bass');
        }

        // App initialisieren (in asynchroner IIFE)
        let audioEngine, piano, settings, patternLoader, player;
        
        (async () => {
            try {
                const components = await initializeApp();
                audioEngine = components.audioEngine;
                piano = components.piano;
                settings = components.settings;
                patternLoader = components.patternLoader;
                player = components.player;
                
                // UI initialisieren nachdem alles geladen ist
                populatePatternDropdown();
                updatePatternInfo();
                setupEventListeners();
                
                console.log('‚úÖ App erfolgreich initialisiert!');
            } catch (error) {
                console.error('‚ùå Fehler bei der App-Initialisierung:', error);
                
                // Notfall-Fallback
                setupEmergencyFallback();
            }
        })();

        // Notfall-Fallback wenn alles fehlschl√§gt
        function setupEmergencyFallback() {
            console.log('üö® Initialisiere Notfall-Fallback...');
            
            // Minimale Komponenten erstellen
            audioEngine = { init: () => {}, playNote: () => {}, close: () => {} };
            piano = { highlightKey: () => {}, unhighlightKey: () => {}, clearAllHighlights: () => {} };
            settings = { 
                getKey: () => 'C', 
                getTempo: () => 120, 
                getSustain: () => true,
                init: () => {}, 
                load: () => {}, 
                save: () => {},
                onKeyChange: () => {},
                onTempoChange: () => {},
                onSustainChange: () => {}
            };
            
            // Einfacher Pattern-Loader mit einem Pattern
            patternLoader = {
                patterns: new Map(),
                registerPattern: function(id, pattern) { this.patterns.set(id, pattern); },
                getPattern: function(id) { return this.patterns.get(id); },
                getAllPatterns: function() { return Array.from(this.patterns.entries()).map(([id, pattern]) => ({ id, ...pattern })); },
                getPatternOptions: function() { return this.getAllPatterns().map(p => ({ value: p.id, label: p.name })); },
                generateABCNotation: () => 'X:1\nT:Fallback\nK:C\nC4 G4 E4 G4 |'
            };
            
            // Minimaler Player
            player = { 
                play: () => console.log('‚ñ∂ Spiele Pattern...'), 
                stop: () => console.log('‚èπ Stoppe Pattern...'),
                isCurrentlyPlaying: () => false
            };
            
            // Fallback-Pattern
            const fallbackPattern = {
                name: 'Notfall-Alberti',
                description: 'Einfaches Fallback-Pattern wenn das System nicht vollst√§ndig geladen werden kann.',
                notation: 'C - G - E - G',
                pattern: () => ['C3', 'G3', 'E3', 'G3'],
                timing: [1, 1, 1, 1]
            };
            
            patternLoader.registerPattern('fallback', fallbackPattern);
            
            // UI initialisieren
            populatePatternDropdown();
            updatePatternInfo();
            setupEventListeners();
            
            console.log('üîß Notfall-System aktiv - Grundfunktionen verf√ºgbar');
        }

        // Populate pattern dropdown
        function populatePatternDropdown() {
            const patternSelect = document.getElementById('pattern');
            const patterns = patternLoader.getPatternOptions();
            
            patternSelect.innerHTML = '';
            patterns.forEach(pattern => {
                const option = document.createElement('option');
                option.value = pattern.value;
                option.textContent = pattern.label;
                patternSelect.appendChild(option);
            });
        }

        // Update pattern info display
        function updatePatternInfo() {
            const patternType = document.getElementById('pattern').value;
            const pattern = patternLoader.getPattern(patternType);
            
            if (pattern) {
                document.getElementById('patternInfo').innerHTML = `
                    <h2>${pattern.name}</h2>
                    <p>${pattern.description}</p>
                `;
                
                // Removed notation display
                
                // Update staff notation
                drawStaffNotation();
            }
        }

        // Draw staff notation using VexFlow
        function drawStaffNotation() {
            const patternType = document.getElementById('pattern').value;
            
            // Sichere Key-Ermittlung
            let key = 'C'; // Fallback
            if (settings && typeof settings.getKey === 'function') {
                key = settings.getKey();
            } else {
                // Direkt aus dem DOM lesen falls settings noch nicht verf√ºgbar
                const keySelect = document.getElementById('key');
                if (keySelect) {
                    key = keySelect.value;
                }
            }
            
            console.log(`üéº Drawing staff notation for pattern: ${patternType}, key: ${key}`);
            
            const notationData = patternLoader.generateVexFlowNotation(patternType, key);
            if (!notationData) return;
            
            // Clear previous notation
            const vexFlowDiv = document.getElementById('vexflow-notation');
            vexFlowDiv.innerHTML = '';
            
            // Check if VexFlow is loaded - version 4.x uses different namespace
            if (typeof Vex === 'undefined') {
                console.error('VexFlow is not loaded properly');
                vexFlowDiv.innerHTML = '<p>Notation library loading... Please wait.</p>';
                // Try again in a second
                setTimeout(drawStaffNotation, 1000);
                return;
            }
            
            try {
                // VexFlow 4.x direct access
                const VF = Vex;
                
                // Create SVG renderer
                const renderer = new VF.Renderer(vexFlowDiv, VF.Renderer.Backends.SVG);
                renderer.resize(800, 300);
                const context = renderer.getContext();
                
                // Create treble clef stave (top)
                const trebleStave = new VF.Stave(10, 40, 750);
                trebleStave.addClef('treble');
                trebleStave.addTimeSignature(notationData.timeSignature);
                trebleStave.addKeySignature(key);
                trebleStave.setContext(context).draw();
                
                // Create bass clef stave (bottom)
                const bassStave = new VF.Stave(10, 140, 750);
                bassStave.addClef('bass');
                bassStave.addTimeSignature(notationData.timeSignature);
                bassStave.addKeySignature(key);
                bassStave.setContext(context).draw();
                
                // Connect the staves with a brace
                const connector = new VF.StaveConnector(trebleStave, bassStave);
                connector.setType(VF.StaveConnector.type.BRACE);
                connector.setContext(context).draw();
                
                // Create notes for both hands
                const trebleNotes = [];
                const bassNotes = [];
                
                // Process bass clef
                if (notationData.bassClef) {
                    notationData.bassClef.notes.forEach((note, index) => {
                        const duration = patternLoader.convertTimingToVexFlowDuration(
                            notationData.bassClef.timing[index % notationData.bassClef.timing.length]
                        );
                        
                        if (note === null) {
                            // Rest
                            bassNotes.push(new VF.StaveNote({ keys: ['b/4'], duration: duration + 'r', clef: 'bass' }));
                        } else {
                            const vexNote = patternLoader.convertToVexFlowNote(note, 'bass');
                            if (Array.isArray(vexNote)) {
                                // Chord
                                const staveNote = new VF.StaveNote({ keys: vexNote, duration: duration, clef: 'bass' });
                                
                                // Add fingering annotations for chords - stacked vertically
                                try {
                                    const fingering = notationData.bassClef.fingering[index % notationData.bassClef.fingering.length];
                                    if (fingering && Array.isArray(fingering)) {
                                        // Add each fingering number to its corresponding note in the chord
                                        fingering.forEach((finger, fingerIndex) => {
                                            if (finger !== null && fingerIndex < vexNote.length) {
                                                const annotation = new VF.Annotation(finger.toString());
                                                annotation.setVerticalJustification(VF.Annotation.VerticalJustify.BOTTOM);
                                                staveNote.addModifier(annotation, fingerIndex);
                                            }
                                        });
                                    }
                                } catch (e) {
                                    console.log('Annotation error:', e);
                                }
                                
                                bassNotes.push(staveNote);
                            } else {
                                // Single note
                                const staveNote = new VF.StaveNote({ keys: [vexNote], duration: duration, clef: 'bass' });
                                
                                // Add fingering annotation
                                try {
                                    const fingering = notationData.bassClef.fingering[index % notationData.bassClef.fingering.length];
                                    if (fingering && fingering !== null && !Array.isArray(fingering)) {
                                        const annotation = new VF.Annotation(fingering.toString());
                                        annotation.setVerticalJustification(VF.Annotation.VerticalJustify.BOTTOM);
                                        staveNote.addModifier(annotation, 0);
                                    }
                                } catch (e) {
                                    console.log('Annotation error:', e);
                                }
                                
                                bassNotes.push(staveNote);
                            }
                        }
                    });
                }
                
                // Process treble clef
                if (notationData.trebleClef) {
                    notationData.trebleClef.notes.forEach((note, index) => {
                        const duration = patternLoader.convertTimingToVexFlowDuration(
                            notationData.trebleClef.timing[index % notationData.trebleClef.timing.length]
                        );
                        
                        if (note === null) {
                            // Rest
                            trebleNotes.push(new VF.StaveNote({ keys: ['b/4'], duration: duration + 'r', clef: 'treble' }));
                        } else {
                            const vexNote = patternLoader.convertToVexFlowNote(note, 'treble');
                            if (Array.isArray(vexNote)) {
                                // Chord
                                const staveNote = new VF.StaveNote({ keys: vexNote, duration: duration, clef: 'treble' });
                                
                                // Add fingering annotations for chords - stacked vertically
                                try {
                                    const fingering = notationData.trebleClef.fingering[index % notationData.trebleClef.fingering.length];
                                    if (fingering && Array.isArray(fingering)) {
                                        // Add each fingering number to its corresponding note in the chord
                                        fingering.forEach((finger, fingerIndex) => {
                                            if (finger !== null && fingerIndex < vexNote.length) {
                                                const annotation = new VF.Annotation(finger.toString());
                                                annotation.setVerticalJustification(VF.Annotation.VerticalJustify.TOP);
                                                staveNote.addModifier(annotation, fingerIndex);
                                            }
                                        });
                                    }
                                } catch (e) {
                                    console.log('Annotation error:', e);
                                }
                                
                                trebleNotes.push(staveNote);
                            } else {
                                // Single note
                                const staveNote = new VF.StaveNote({ keys: [vexNote], duration: duration, clef: 'treble' });
                                
                                // Add fingering annotation
                                try {
                                    const fingering = notationData.trebleClef.fingering[index % notationData.trebleClef.fingering.length];
                                    if (fingering && fingering !== null && !Array.isArray(fingering)) {
                                        const annotation = new VF.Annotation(fingering.toString());
                                        annotation.setVerticalJustification(VF.Annotation.VerticalJustify.TOP);
                                        staveNote.addModifier(annotation, 0);
                                    }
                                } catch (e) {
                                    console.log('Annotation error:', e);
                                }
                                
                                trebleNotes.push(staveNote);
                            }
                        }
                    });
                } else {
                    // Fill treble staff with rests if no treble clef
                    notationData.bassClef.notes.forEach((note, index) => {
                        const duration = patternLoader.convertTimingToVexFlowDuration(
                            notationData.bassClef.timing[index % notationData.bassClef.timing.length]
                        );
                        trebleNotes.push(new VF.StaveNote({ keys: ['b/4'], duration: duration + 'r', clef: 'treble' }));
                    });
                }
                
                // Calculate the total beats for the voice
                const timeSignatureParts = notationData.timeSignature.split('/');
                const numBeats = parseInt(timeSignatureParts[0]);
                const beatValue = parseInt(timeSignatureParts[1]);
                
                // Create voices and format
                if (trebleNotes.length > 0) {
                    const trebleVoice = new VF.Voice({ num_beats: numBeats, beat_value: beatValue });
                    trebleVoice.setStrict(false); // Allow incomplete voices
                    trebleVoice.addTickables(trebleNotes);
                    new VF.Formatter().joinVoices([trebleVoice]).format([trebleVoice], 700);
                    trebleVoice.draw(context, trebleStave);
                }
                
                if (bassNotes.length > 0) {
                    const bassVoice = new VF.Voice({ num_beats: numBeats, beat_value: beatValue });
                    bassVoice.setStrict(false); // Allow incomplete voices
                    bassVoice.addTickables(bassNotes);
                    new VF.Formatter().joinVoices([bassVoice]).format([bassVoice], 700);
                    bassVoice.draw(context, bassStave);
                }
                
            } catch (error) {
                console.error('VexFlow rendering error:', error);
                vexFlowDiv.innerHTML = '<p>Fehler beim Rendern der Notation</p>';
            }
        }

        // Event handlers
        function handlePlay() {
            player.stop();
            setTimeout(() => {
                const patternType = document.getElementById('pattern').value;
                const pattern = patternLoader.getPattern(patternType);
                const key = settings.getKey();
                
                if (pattern) {
                    player.play(pattern, key);
                    document.getElementById('playBtn').classList.add('playing');
                }
            }, 100);
        }

        function handleStop() {
            player.stop();
            document.getElementById('playBtn').classList.remove('playing');
        }

        function handlePatternChange() {
            player.stop();
            document.getElementById('playBtn').classList.remove('playing');
            updatePatternInfo();
        }

        function handleKeyChange() {
            console.log('üéµ Key changed, updating notation...');
            player.stop();
            document.getElementById('playBtn').classList.remove('playing');
            drawStaffNotation();
        }

        // Setup event listeners (wird nach der Initialisierung aufgerufen)
        function setupEventListeners() {
            document.getElementById('playBtn').addEventListener('click', handlePlay);
            document.getElementById('stopBtn').addEventListener('click', handleStop);
            document.getElementById('pattern').addEventListener('change', handlePatternChange);
            
            // Key select direkter Event Listener zus√§tzlich zu settings callbacks
            document.getElementById('key').addEventListener('change', handleKeyChange);
            
            // Direkter Tempo-Slider Event Listener (Fallback)
            const tempoSlider = document.getElementById('tempo');
            if (tempoSlider) {
                console.log('üîß F√ºge direkten Tempo Event Listener hinzu');
                tempoSlider.addEventListener('input', (e) => {
                    const newTempo = parseInt(e.target.value);
                    console.log(`üéµ Direkter Tempo Change: ${newTempo} BPM`);
                    if (settings && typeof settings.setTempo === 'function') {
                        settings.setTempo(newTempo);
                    }
                    // Update display directly
                    const display = document.getElementById('tempoDisplay');
                    if (display) {
                        display.textContent = `${newTempo} BPM`;
                    }
                });
            }

            // Settings callbacks (falls settings verf√ºgbar)
            if (settings && typeof settings.onKeyChange === 'function') {
                settings.onKeyChange(handleKeyChange);
                settings.onTempoChange(() => {
                    // Save settings when changed
                    settings.save();
                });
                settings.onSustainChange(() => {
                    settings.save();
                });
            }
        }

        // UI wird nach erfolgreicher Initialisierung geladen

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            player.stop();
            audioEngine.close();
            settings.save();
        });
    </script>
</body>
</html>