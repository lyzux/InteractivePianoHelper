<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Piano Bass Rhythms</title>
    <script src="https://cdn.jsdelivr.net/npm/vexflow@4.2.2/build/cjs/vexflow.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Libre+Baskerville:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="css/styles.css">
    <style>
        .main-layout {
            display: flex;
            gap: 20px;
            width: 95%;
            margin: 0 auto;
            padding: 20px;
            position: relative;
            min-height: calc(100vh - 200px);
        }
        
        .piano-section {
            flex: 1;
            min-width: 800px;
            display: flex;
            flex-direction: column;
        }
        
        .physics-sidebar {
            width: 400px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-height: calc(100vh - 280px);
            overflow-y: auto;
        }
        
        .physics-sidebar h3 {
            margin-top: 0;
            color: #333;
            border-bottom: 2px solid #ddd;
            padding-bottom: 10px;
        }
        
        .param-group {
            margin-bottom: 15px;
        }
        
        .param-label {
            display: block;
            font-size: 0.9em;
            margin-bottom: 5px;
            color: #555;
            font-weight: 500;
        }
        
        .param-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .param-slider {
            flex: 1;
            height: 6px;
            background: #ddd;
            border-radius: 3px;
            outline: none;
            appearance: none;
            cursor: pointer;
        }
        
        .param-slider::-webkit-slider-thumb {
            appearance: none;
            width: 18px;
            height: 18px;
            background: #4CAF50;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .param-value {
            min-width: 45px;
            text-align: right;
            font-family: monospace;
            font-size: 0.85em;
            color: #666;
        }
        
        .test-piano {
            margin-top: 20px;
            text-align: center;
        }
        
        .test-btn {
            padding: 8px 12px;
            margin: 2px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.8em;
        }
        
        .test-btn:hover {
            background: #45a049;
        }
        
        .content-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            margin-bottom: 20px;
        }
        
        .piano-keyboard-container {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            z-index: 1000;
            border-top: 2px solid #333;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        body {
            padding-bottom: 120px;
        }

        @media (max-width: 1200px) {
            .main-layout {
                flex-direction: column;
                width: 98%;
            }
            .physics-sidebar {
                width: 100%;
                max-height: 400px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Piano Patterns</h1>
        
        <div class="main-layout">
            <div class="piano-section">
                <div class="content-area">
                    <div class="controls">
            <div class="control-group">
                <label for="pattern">Rhythm Pattern</label>
                <select id="pattern">
                    <!-- Patterns will be populated by JavaScript -->
                </select>
            </div>
            
            <div class="control-group">
                <label for="key">Key</label>
                <select id="key">
                    <option value="C">C Major</option>
                    <option value="G">G Major</option>
                    <option value="F">F Major</option>
                    <option value="Am">A Minor</option>
                    <option value="Dm">D Minor</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="tempo">Tempo (BPM)</label>
                <input type="range" id="tempo" min="60" max="180" value="120">
                <div class="tempo-display" id="tempoDisplay">120 BPM</div>
            </div>
            
            
            <div class="control-group">
                <label>&nbsp;</label>
                <button id="playStopBtn">Play</button>
            </div>
            
            <div class="control-group">
                <label>&nbsp;</label>
                <div class="pedal-control">
                    <input type="checkbox" id="sustain" checked>
                    <label for="sustain">Sustain Pedal</label>
                </div>
            </div>
            
        </div>
        
        <div class="pattern-info" id="patternInfo">
            <h2>Pattern Details</h2>
            <p>Select a rhythm pattern to see details.</p>
        </div>
        
        
        <div class="staff-notation">
            <h3>Staff Notation:</h3>
            <div id="vexflow-notation"></div>
        </div>
                </div>
            </div>
            
            <div class="physics-sidebar">
                <h3>Piano Controls</h3>
                <div id="physicsControls">
                    <!-- Physics controls will be generated here -->
                </div>
                
                <div class="test-piano">
                    <h4>Test Sound</h4>
                    <button class="test-btn" onclick="testNote('C3')">C3</button>
                    <button class="test-btn" onclick="testNote('C4')">C4</button>
                    <button class="test-btn" onclick="testNote('C5')">C5</button>
                    <br>
                    <button class="test-btn" onclick="testChord()">Chord</button>
                    <button class="test-btn" onclick="testScale()">Scale</button>
                </div>
            </div>
        </div>
        
        <!-- Piano keyboard at bottom of screen -->
        <div class="piano-keyboard-container">
            <div class="piano-container">
                <div class="piano" id="piano">
                    <!-- Piano keys will be generated by JavaScript -->
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        console.log('SCRIPT STARTING TO EXECUTE');
        
        // Simple Pattern-Loader class defined directly here
        class SimplePatternLoader {
            constructor() {
                this.patterns = new Map();
            }

            registerPattern(id, pattern) {
                this.patterns.set(id, pattern);
            }

            getPattern(id) {
                return this.patterns.get(id);
            }

            getAllPatterns() {
                return Array.from(this.patterns.entries()).map(([id, pattern]) => ({
                    id, ...pattern
                }));
            }

            getPatternOptions() {
                return this.getAllPatterns().map(pattern => ({
                    value: pattern.id,
                    label: pattern.name
                }));
            }

            generateVexFlowNotation(patternId, key) {
                const pattern = this.getPattern(patternId);
                if (!pattern) return null;

                const patternData = pattern.pattern(key);
                const timing = pattern.timing;
                
                // Get bass and treble clef data
                const bassClefNotes = pattern.bassClef ? pattern.bassClef(key) : (pattern.leftHand ? pattern.leftHand(key) : patternData);
                const trebleClefNotes = pattern.trebleClef ? pattern.trebleClef(key) : (pattern.rightHand ? pattern.rightHand(key) : null);
                const bassClefFingering = pattern.bassClefFingering || pattern.leftHandFingering || pattern.fingering;
                const trebleClefFingering = pattern.trebleClefFingering || pattern.rightHandFingering;
                
                return {
                    bassClef: {
                        notes: bassClefNotes,
                        fingering: bassClefFingering,
                        timing: timing
                    },
                    trebleClef: trebleClefNotes ? {
                        notes: trebleClefNotes,
                        fingering: trebleClefFingering,
                        timing: timing
                    } : null,
                    timeSignature: pattern.timeSignature || '4/4',
                    key: key
                };
            }

            // Convert note string to VexFlow format
            convertToVexFlowNote(note, clef = 'treble') {
                if (!note) return null; // Rest
                
                if (Array.isArray(note)) {
                    // Chord - return array of note strings
                    return note.map(n => this.convertSingleNoteToVexFlow(n, clef));
                }
                
                return this.convertSingleNoteToVexFlow(note, clef);
            }
            
            // Helper function to convert single note to VexFlow format
            convertSingleNoteToVexFlow(note, clef = 'treble') {
                let noteName = note.charAt(0).toLowerCase();
                let octave = parseInt(note.slice(-1));
                let accidental = note.slice(1, -1);
                
                // Handle accidentals - VexFlow uses # and b directly
                if (accidental === '#') {
                    noteName += '#';
                } else if (accidental === 'b') {
                    noteName += 'b';
                }
                
                // VexFlow octave mapping - no adjustment needed when clef is properly specified
                const adjustedOctave = octave;
                
                const result = `${noteName}/${adjustedOctave}`;
                console.log(`Converting ${note} for ${clef} clef: ${result}`);
                
                return result;
            }

            // Convert timing to VexFlow duration
            convertTimingToVexFlowDuration(timing) {
                if (timing === 0.25) return '16'; // Sixteenth note
                if (timing === 0.5) return '8';   // Eighth note
                if (timing === 0.75) return '8d'; // Dotted eighth
                if (timing === 1) return 'q';     // Quarter note
                if (timing === 1.5) return 'qd';  // Dotted quarter
                if (timing === 2) return 'h';     // Half note
                if (timing === 3) return 'hd';    // Dotted half
                if (timing === 4) return 'w';     // Whole note
                return 'q'; // Default to quarter note
            }

            // Automatic loading of all patterns
            async autoLoadPatterns() {
                console.log('Loading patterns automatically...');
                
                const knownPatterns = [
                    'alberti', 'waltz', 'march', 'boogie', 'stride', 'bossa',
                    'ragtime', 'ballad', 'tango', 'habanera', 'arpeggien',
                    'lombardisch', 'chaconne', 'oktav', 'ostinato', 'pompa', 'polonaise',
                    'classical', 'hymn', 'furelise'
                ];

                let loadedCount = 0;
                for (const patternId of knownPatterns) {
                    try {
                        console.log(`Attempting to load: ${patternId}`);
                        // Cache-busting for updated pattern files
                        const timestamp = Date.now();
                        const module = await import(`./patterns/${patternId}.js?v=${timestamp}`);
                        const pattern = module[patternId];
                        
                        if (pattern) {
                            this.registerPattern(patternId, pattern);
                            console.log(`Loaded: ${pattern.name}`);
                            
                            // Debug: Show pattern data for patterns with rests
                            if (['polonaise', 'tango', 'bossa'].includes(patternId)) {
                                const testNotes = pattern.pattern('C');
                                console.log(`Debug ${patternId}:`, testNotes);
                                console.log(`Timing ${patternId}:`, pattern.timing);
                                console.log(`Fingering ${patternId}:`, pattern.fingering);
                            }
                            
                            loadedCount++;
                        }
                    } catch (error) {
                        console.log(`${patternId}.js not found`);
                    }
                }

                console.log(`${loadedCount} Patterns loaded!`);
                
                // Debug: Test rest patterns
                this.addTestPattern();
                
                return loadedCount > 0;
            }

            // Debug: Create test pattern with rests
            addTestPattern() {
                const testPattern = {
                    name: 'Test-Rests',
                    description: 'Test pattern to check rests',
                    notation: 'C3 - (Rest) - G3 - (Rest)',
                    pattern: (key) => {
                        return ['C3', null, 'G3', null];
                    },
                    timing: [1, 1, 1, 1],
                    fingering: [5, null, 3, null],
                    timeSignature: '4/4',
                    tempo: { min: 80, max: 120, default: 100 }
                };
                
                this.registerPattern('test-pausen', testPattern);
                console.log('Test-Rests Pattern added');
            }
        }

        // Import modules (only the working ones)
        console.log('ABOUT TO IMPORT MODULES');
        import { AudioEngine } from './js/audioEngine.js?v=20250824013';
        console.log('IMPORTED AudioEngine');
        import { Piano } from './js/piano.js?v=20250824001';
        console.log('IMPORTED Piano');
        import { Settings } from './js/settings.js?v=20250824001';
        console.log('IMPORTED Settings');
        import { Player } from './js/player.js?v=20250824001';
        console.log('IMPORTED Player');

        // Asynchronous initialization
        async function initializeApp() {
            console.log('INITIALIZE APP CALLED');
            // Initialize components
            console.log('CREATING AudioEngine');
            const audioEngine = new AudioEngine();
            console.log('CREATING Piano');
            let piano;
            try {
                piano = new Piano('piano', audioEngine);
                console.log('PIANO CREATED SUCCESSFULLY');
            } catch (error) {
                console.error('ERROR CREATING PIANO:', error);
                throw error;
            }
            console.log('CREATING Settings');
            const settings = new Settings();
            console.log('CREATING PatternLoader');
            const patternLoader = new SimplePatternLoader(); // Use simple version
            console.log('CREATING Player');
            const player = new Player(audioEngine, piano, settings);
            
            // Generate physics controls after audioEngine is available
            setTimeout(() => {
                console.log('Attempting to generate physics controls...');
                generatePhysicsControls();
            }, 500);

            // Load patterns automatically
            console.log('Starting automatic pattern loading...');
            const success = await patternLoader.autoLoadPatterns();
            
            if (!success || patternLoader.getAllPatterns().length === 0) {
                console.warn('Automatic loading failed - using fallback');
                await loadPatternsFallback(patternLoader);
            }

            // Initialize settings
            console.log('Initializing Settings...');
            settings.init('tempo', 'tempoDisplay', 'sustain', 'key');
            
            // Try to load saved settings
            settings.load();
            
            // Debug: Test if tempo slider was found
            const tempoSlider = document.getElementById('tempo');
            console.log('Tempo Slider found:', tempoSlider);
            if (tempoSlider) {
                console.log('Tempo Slider Value:', tempoSlider.value);
            }

            return { audioEngine, piano, settings, patternLoader, player };
        }

        // Fallback: Manual pattern registration if auto-load fails
        async function loadPatternsFallback(patternLoader) {
            console.log('Loading patterns manually as fallback...');
            
            // Minimal fallback with one pattern
            const albertiPattern = {
                name: 'Alberti-Bass',
                description: 'A classic accompaniment pattern, named after Domenico Alberti.',
                notation: 'C - G - E - G (1 - 5 - 3 - 5)',
                pattern: (key) => {
                    const patterns = {
                        'C': ['C3', 'G3', 'E3', 'G3'],
                        'G': ['G2', 'D3', 'B2', 'D3'],
                        'F': ['F3', 'C4', 'A3', 'C4'],
                        'Am': ['A2', 'E3', 'C3', 'E3'],
                        'Dm': ['D3', 'A3', 'F3', 'A3']
                    };
                    return patterns[key];
                },
                timing: [1, 1, 1, 1],
                fingering: [1, 5, 3, 5],
                timeSignature: '4/4'
            };
            
            patternLoader.registerPattern('alberti', albertiPattern);
            console.log('Fallback Pattern loaded: Alberti-Bass');
        }

        // Initialize app (in asynchronous IIFE)
        let audioEngine, piano, settings, patternLoader, player;
        
        // Make audioEngine globally accessible for physics controls
        window.audioEngine = null;
        
        (async () => {
            try {
                const components = await initializeApp();
                audioEngine = components.audioEngine;
                piano = components.piano;
                settings = components.settings;
                patternLoader = components.patternLoader;
                player = components.player;
                
                // Make audioEngine globally accessible
                window.audioEngine = audioEngine;
                
                // Generate physics controls now that audioEngine is available
                generatePhysicsControls();
                
                // Initialize UI after everything is loaded
                populatePatternDropdown();
                updatePatternInfo();
                setupEventListeners();
                
                console.log('App successfully initialized!');
            } catch (error) {
                console.error('Error during app initialization:', error);
                
                // Emergency fallback
                setupEmergencyFallback();
            }
        })();

        // Emergency fallback when everything fails
        function setupEmergencyFallback() {
            console.log('Initializing emergency fallback...');
            
            // Create minimal components
            audioEngine = { 
                init: () => {}, 
                playNote: () => {}, 
                close: () => {},
                setLidPosition: () => {},
                getLidPosition: () => 0,
                loadPhysicsParameters: () => false,
                savePhysicsParameters: () => false
            };
            piano = { highlightKey: () => {}, unhighlightKey: () => {}, clearAllHighlights: () => {} };
            settings = { 
                getKey: () => 'C', 
                getTempo: () => 120, 
                getSustain: () => true,
                init: () => {}, 
                load: () => {}, 
                save: () => {},
                onKeyChange: () => {},
                onTempoChange: () => {},
                onSustainChange: () => {}
            };
            
            // Simple pattern loader with one pattern
            patternLoader = {
                patterns: new Map(),
                registerPattern: function(id, pattern) { this.patterns.set(id, pattern); },
                getPattern: function(id) { return this.patterns.get(id); },
                getAllPatterns: function() { return Array.from(this.patterns.entries()).map(([id, pattern]) => ({ id, ...pattern })); },
                getPatternOptions: function() { return this.getAllPatterns().map(p => ({ value: p.id, label: p.name })); },
                generateABCNotation: () => 'X:1\nT:Fallback\nK:C\nC4 G4 E4 G4 |',
                generateVexFlowNotation: function(patternId, key) {
                    return {
                        bassClef: {
                            notes: ['C3', 'G3', 'E3', 'G3'],
                            timing: [1, 1, 1, 1],
                            fingering: [1, 5, 3, 5]
                        },
                        trebleClef: null,
                        timeSignature: '4/4',
                        key: key
                    };
                },
                convertTimingToVexFlowDuration: function(timing) {
                    return 'q'; // Quarter note
                },
                convertToVexFlowNote: function(note, clef) {
                    if (!note) return null;
                    return note.toLowerCase() + '/3';
                }
            };
            
            // Minimal player
            player = { 
                play: () => console.log('Playing Pattern...'), 
                stop: () => console.log('Stopping Pattern...'),
                isCurrentlyPlaying: () => false
            };
            
            // Fallback-Pattern
            const fallbackPattern = {
                name: 'Emergency-Alberti',
                description: 'Simple fallback pattern when the system cannot be fully loaded.',
                notation: 'C - G - E - G',
                pattern: () => ['C3', 'G3', 'E3', 'G3'],
                timing: [1, 1, 1, 1]
            };
            
            patternLoader.registerPattern('fallback', fallbackPattern);
            
            // Initialize UI
            populatePatternDropdown();
            updatePatternInfo();
            setupEventListeners();
            
            console.log('Emergency system active - basic functions available');
        }

        // Populate pattern dropdown
        function populatePatternDropdown() {
            const patternSelect = document.getElementById('pattern');
            const patterns = patternLoader.getPatternOptions();
            
            patternSelect.innerHTML = '';
            patterns.forEach(pattern => {
                const option = document.createElement('option');
                option.value = pattern.value;
                option.textContent = pattern.label;
                patternSelect.appendChild(option);
            });
        }

        // Update pattern info display
        function updatePatternInfo() {
            const patternType = document.getElementById('pattern').value;
            const pattern = patternLoader.getPattern(patternType);
            
            if (pattern) {
                document.getElementById('patternInfo').innerHTML = `
                    <h2>${pattern.name}</h2>
                    <p>${pattern.description}</p>
                `;
                
                // Removed notation display
                
                // Update staff notation
                drawStaffNotation();
            }
        }

        // Draw staff notation using VexFlow
        function drawStaffNotation() {
            const patternType = document.getElementById('pattern').value;
            
            // Safe key determination
            let key = 'C'; // Fallback
            if (settings && typeof settings.getKey === 'function') {
                key = settings.getKey();
            } else {
                // Read directly from DOM if settings not yet available
                const keySelect = document.getElementById('key');
                if (keySelect) {
                    key = keySelect.value;
                }
            }
            
            console.log(`Drawing staff notation for pattern: ${patternType}, key: ${key}`);
            
            const notationData = patternLoader.generateVexFlowNotation(patternType, key);
            if (!notationData) return;
            
            // Clear previous notation
            const vexFlowDiv = document.getElementById('vexflow-notation');
            vexFlowDiv.innerHTML = '';
            
            // Check if VexFlow is loaded - version 4.x uses different namespace
            if (typeof Vex === 'undefined') {
                console.error('VexFlow is not loaded properly');
                vexFlowDiv.innerHTML = '<p>Notation library loading... Please wait.</p>';
                // Try again in a second
                setTimeout(drawStaffNotation, 1000);
                return;
            }
            
            try {
                // VexFlow 4.x direct access
                const VF = Vex;
                
                // Create SVG renderer
                const renderer = new VF.Renderer(vexFlowDiv, VF.Renderer.Backends.SVG);
                renderer.resize(800, 300);
                const context = renderer.getContext();
                
                // Create treble clef stave (top)
                const trebleStave = new VF.Stave(10, 40, 750);
                trebleStave.addClef('treble');
                trebleStave.addTimeSignature(notationData.timeSignature);
                trebleStave.addKeySignature(key);
                trebleStave.setContext(context).draw();
                
                // Create bass clef stave (bottom)
                const bassStave = new VF.Stave(10, 140, 750);
                bassStave.addClef('bass');
                bassStave.addTimeSignature(notationData.timeSignature);
                bassStave.addKeySignature(key);
                bassStave.setContext(context).draw();
                
                // Connect the staves with a brace
                const connector = new VF.StaveConnector(trebleStave, bassStave);
                connector.setType(VF.StaveConnector.type.BRACE);
                connector.setContext(context).draw();
                
                // Create notes for both hands
                const trebleNotes = [];
                const bassNotes = [];
                
                // Process bass clef
                if (notationData.bassClef) {
                    notationData.bassClef.notes.forEach((note, index) => {
                        const duration = patternLoader.convertTimingToVexFlowDuration(
                            notationData.bassClef.timing[index % notationData.bassClef.timing.length]
                        );
                        
                        if (note === null) {
                            // Rest
                            bassNotes.push(new VF.StaveNote({ keys: ['b/4'], duration: duration + 'r', clef: 'bass' }));
                        } else {
                            const vexNote = patternLoader.convertToVexFlowNote(note, 'bass');
                            if (Array.isArray(vexNote)) {
                                // Chord
                                const staveNote = new VF.StaveNote({ keys: vexNote, duration: duration, clef: 'bass' });
                                
                                // Add fingering annotations for chords - stacked vertically
                                try {
                                    const fingering = notationData.bassClef.fingering[index % notationData.bassClef.fingering.length];
                                    if (fingering && Array.isArray(fingering)) {
                                        // Add each fingering number to its corresponding note in the chord
                                        fingering.forEach((finger, fingerIndex) => {
                                            if (finger !== null && fingerIndex < vexNote.length) {
                                                const annotation = new VF.Annotation(finger.toString());
                                                annotation.setVerticalJustification(VF.Annotation.VerticalJustify.BOTTOM);
                                                staveNote.addModifier(annotation, fingerIndex);
                                            }
                                        });
                                    }
                                } catch (e) {
                                    console.log('Annotation error:', e);
                                }
                                
                                bassNotes.push(staveNote);
                            } else {
                                // Single note
                                const staveNote = new VF.StaveNote({ keys: [vexNote], duration: duration, clef: 'bass' });
                                
                                // Add fingering annotation
                                try {
                                    const fingering = notationData.bassClef.fingering[index % notationData.bassClef.fingering.length];
                                    if (fingering && fingering !== null && !Array.isArray(fingering)) {
                                        const annotation = new VF.Annotation(fingering.toString());
                                        annotation.setVerticalJustification(VF.Annotation.VerticalJustify.BOTTOM);
                                        staveNote.addModifier(annotation, 0);
                                    }
                                } catch (e) {
                                    console.log('Annotation error:', e);
                                }
                                
                                bassNotes.push(staveNote);
                            }
                        }
                    });
                }
                
                // Process treble clef
                if (notationData.trebleClef) {
                    notationData.trebleClef.notes.forEach((note, index) => {
                        const duration = patternLoader.convertTimingToVexFlowDuration(
                            notationData.trebleClef.timing[index % notationData.trebleClef.timing.length]
                        );
                        
                        if (note === null) {
                            // Rest
                            trebleNotes.push(new VF.StaveNote({ keys: ['b/4'], duration: duration + 'r', clef: 'treble' }));
                        } else {
                            const vexNote = patternLoader.convertToVexFlowNote(note, 'treble');
                            if (Array.isArray(vexNote)) {
                                // Chord
                                const staveNote = new VF.StaveNote({ keys: vexNote, duration: duration, clef: 'treble' });
                                
                                // Add fingering annotations for chords - stacked vertically
                                try {
                                    const fingering = notationData.trebleClef.fingering[index % notationData.trebleClef.fingering.length];
                                    if (fingering && Array.isArray(fingering)) {
                                        // Add each fingering number to its corresponding note in the chord
                                        fingering.forEach((finger, fingerIndex) => {
                                            if (finger !== null && fingerIndex < vexNote.length) {
                                                const annotation = new VF.Annotation(finger.toString());
                                                annotation.setVerticalJustification(VF.Annotation.VerticalJustify.TOP);
                                                staveNote.addModifier(annotation, fingerIndex);
                                            }
                                        });
                                    }
                                } catch (e) {
                                    console.log('Annotation error:', e);
                                }
                                
                                trebleNotes.push(staveNote);
                            } else {
                                // Single note
                                const staveNote = new VF.StaveNote({ keys: [vexNote], duration: duration, clef: 'treble' });
                                
                                // Add fingering annotation
                                try {
                                    const fingering = notationData.trebleClef.fingering[index % notationData.trebleClef.fingering.length];
                                    if (fingering && fingering !== null && !Array.isArray(fingering)) {
                                        const annotation = new VF.Annotation(fingering.toString());
                                        annotation.setVerticalJustification(VF.Annotation.VerticalJustify.TOP);
                                        staveNote.addModifier(annotation, 0);
                                    }
                                } catch (e) {
                                    console.log('Annotation error:', e);
                                }
                                
                                trebleNotes.push(staveNote);
                            }
                        }
                    });
                } else {
                    // Fill treble staff with rests if no treble clef
                    notationData.bassClef.notes.forEach((note, index) => {
                        const duration = patternLoader.convertTimingToVexFlowDuration(
                            notationData.bassClef.timing[index % notationData.bassClef.timing.length]
                        );
                        trebleNotes.push(new VF.StaveNote({ keys: ['b/4'], duration: duration + 'r', clef: 'treble' }));
                    });
                }
                
                // Calculate the total beats for the voice
                const timeSignatureParts = notationData.timeSignature.split('/');
                const numBeats = parseInt(timeSignatureParts[0]);
                const beatValue = parseInt(timeSignatureParts[1]);
                
                // Create voices and format
                if (trebleNotes.length > 0) {
                    const trebleVoice = new VF.Voice({ num_beats: numBeats, beat_value: beatValue });
                    trebleVoice.setStrict(false); // Allow incomplete voices
                    trebleVoice.addTickables(trebleNotes);
                    new VF.Formatter().joinVoices([trebleVoice]).format([trebleVoice], 700);
                    trebleVoice.draw(context, trebleStave);
                }
                
                if (bassNotes.length > 0) {
                    const bassVoice = new VF.Voice({ num_beats: numBeats, beat_value: beatValue });
                    bassVoice.setStrict(false); // Allow incomplete voices
                    bassVoice.addTickables(bassNotes);
                    new VF.Formatter().joinVoices([bassVoice]).format([bassVoice], 700);
                    bassVoice.draw(context, bassStave);
                }
                
            } catch (error) {
                console.error('VexFlow rendering error:', error);
                vexFlowDiv.innerHTML = '<p>Error rendering notation</p>';
            }
        }

        // Event handlers
        function handlePlayStop() {
            const button = document.getElementById('playStopBtn');
            
            if (player.isCurrentlyPlaying()) {
                // Currently playing - stop it
                player.stop();
                button.classList.remove('playing');
                button.textContent = 'Play';
            } else {
                // Not playing - start it
                player.stop(); // Ensure clean state
                setTimeout(() => {
                    const patternType = document.getElementById('pattern').value;
                    const pattern = patternLoader.getPattern(patternType);
                    const key = settings.getKey();
                    
                    if (pattern) {
                        player.play(pattern, key);
                        button.classList.add('playing');
                        button.textContent = 'Stop';
                    }
                }, 100);
            }
        }

        function handlePatternChange() {
            player.stop();
            const button = document.getElementById('playStopBtn');
            button.classList.remove('playing');
            button.textContent = 'Play';
            updatePatternInfo();
        }

        function handleKeyChange() {
            console.log('Key changed, updating notation...');
            player.stop();
            const button = document.getElementById('playStopBtn');
            button.classList.remove('playing');
            button.textContent = 'Play';
            drawStaffNotation();
        }

        // Setup event listeners (called after initialization)
        function setupEventListeners() {
            document.getElementById('playStopBtn').addEventListener('click', handlePlayStop);
            document.getElementById('pattern').addEventListener('change', handlePatternChange);
            
            // Key select direct event listener in addition to settings callbacks
            document.getElementById('key').addEventListener('change', handleKeyChange);
            
            // Direct tempo slider event listener (fallback)
            const tempoSlider = document.getElementById('tempo');
            if (tempoSlider) {
                console.log('Adding direct tempo event listener');
                tempoSlider.addEventListener('input', (e) => {
                    const newTempo = parseInt(e.target.value);
                    console.log(`Direct Tempo Change: ${newTempo} BPM`);
                    if (settings && typeof settings.setTempo === 'function') {
                        settings.setTempo(newTempo);
                    }
                    // Update display directly
                    const display = document.getElementById('tempoDisplay');
                    if (display) {
                        display.textContent = `${newTempo} BPM`;
                    }
                });
            }


            // Settings callbacks (if settings available)
            if (settings && typeof settings.onKeyChange === 'function') {
                settings.onKeyChange(handleKeyChange);
                settings.onTempoChange(() => {
                    // Save settings when changed
                    settings.save();
                });
                settings.onSustainChange(() => {
                    settings.save();
                });
            }
        }

        // Generate physics controls
        function generatePhysicsControls() {
            console.log('generatePhysicsControls called');
            
            const container = document.getElementById('physicsControls');
            console.log('Container found:', !!container);
            
            const engine = window.audioEngine || audioEngine;
            console.log('AudioEngine found:', !!engine);
            console.log('AudioEngine type:', typeof engine);
            
            if (!container) {
                console.error('Physics controls container not found');
                return;
            }
            
            if (!engine) {
                console.error('AudioEngine not available');
                return;
            }
            
            // Clear existing controls
            container.innerHTML = '';
            
            console.log('Generating physics controls...');
            
            const paramDefs = {
                volume: { min: 0, max: 1, step: 0.01, label: 'Volume' },
                brightness: { min: 0, max: 1, step: 0.01, label: 'Brightness' },
                warmth: { min: 0, max: 1, step: 0.01, label: 'Warmth' },
                attack: { min: 0.001, max: 0.1, step: 0.001, label: 'Attack' },
                release: { min: 0.5, max: 5, step: 0.1, label: 'Release' },
                harmonics: { min: 0, max: 1, step: 0.01, label: 'Harmonics' },
                detune: { min: 0, max: 1, step: 0.01, label: 'Detune' },
                chorus: { min: 0, max: 1, step: 0.01, label: 'Chorus' },
                roomSize: { min: 0, max: 1, step: 0.01, label: 'Room Size' },
                damping: { min: 0, max: 1, step: 0.01, label: 'Damping' },
                lidPosition: { min: 0, max: 1, step: 0.01, label: 'Lid Position' },
                pedalResonance: { min: 0, max: 1, step: 0.01, label: 'Pedal Resonance' }
            };
            
            let controlsCreated = 0;
            
            Object.entries(paramDefs).forEach(([param, def]) => {
                console.log(`Creating control for ${param}`);
                
                const group = document.createElement('div');
                group.className = 'param-group';
                
                const label = document.createElement('label');
                label.className = 'param-label';
                label.textContent = def.label;
                
                const control = document.createElement('div');
                control.className = 'param-control';
                
                const slider = document.createElement('input');
                slider.type = 'range';
                slider.className = 'param-slider';
                slider.min = def.min;
                slider.max = def.max;
                slider.step = def.step;
                
                // Get current parameter value
                const currentValue = engine.getParam ? engine.getParam(param) : 0.5;
                slider.value = currentValue;
                console.log(`${param} current value: ${currentValue}`);
                
                const value = document.createElement('span');
                value.className = 'param-value';
                value.textContent = parseFloat(slider.value).toFixed(2);
                
                slider.addEventListener('input', (e) => {
                    const newValue = parseFloat(e.target.value);
                    value.textContent = newValue.toFixed(2);
                    console.log(`${param} changed to: ${newValue}`);
                    if (engine.setParam) {
                        engine.setParam(param, newValue);
                    }
                });
                
                control.appendChild(slider);
                control.appendChild(value);
                group.appendChild(label);
                group.appendChild(control);
                container.appendChild(group);
                
                controlsCreated++;
            });
            
            console.log(`Created ${controlsCreated} physics controls`);
        }
        
        // Test functions
        window.testNote = function(note) {
            const engine = window.audioEngine || audioEngine;
            if (engine) {
                engine.playNote(note, 2.0, true, 0.8);
            }
        };
        
        window.testChord = function() {
            const engine = window.audioEngine || audioEngine;
            if (engine) {
                const chord = ['C4', 'E4', 'G4'];
                chord.forEach((note, index) => {
                    setTimeout(() => engine.playNote(note, 2.0, true, 0.7), index * 50);
                });
            }
        };
        
        window.testScale = function() {
            const engine = window.audioEngine || audioEngine;
            if (engine) {
                const scale = ['C4', 'D4', 'E4', 'F4', 'G4', 'A4', 'B4', 'C5'];
                scale.forEach((note, index) => {
                    setTimeout(() => engine.playNote(note, 0.8, false, 0.6), index * 200);
                });
            }
        };

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            player.stop();
            audioEngine.close();
            settings.save();
        });
    </script>
</body>
</html>